---
phase: 02-stats-retrieval-display
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified: [index.js, dist/index.js]
autonomous: true

must_haves:
  truths:
    - "User with legacy TODO-IST:START/END tags sees all stats displayed"
    - "User with granular TODO-IST-KARMA:START/END tags sees only karma displayed"
    - "User with multiple granular tags sees each stat in its designated location"
    - "User with typos or missing tags sees helpful warning messages in action logs"
  artifacts:
    - path: "index.js"
      provides: "Dual-mode tag detection and processing"
      contains: "detectDisplayMode|updateReadmeGranular|replaceTag"
    - path: "index.js"
      provides: "Granular tag configuration"
      contains: "TAG_CONFIG|TODO-IST-KARMA|TODO-IST-DAILY"
  key_links:
    - from: "index.js:updateReadme"
      to: "detectDisplayMode"
      via: "function call to determine mode"
      pattern: "detectDisplayMode\\("
    - from: "index.js:updateReadmeGranular"
      to: "formatter functions"
      via: "TAG_CONFIG mapping"
      pattern: "TAG_CONFIG"
---

<objective>
Implement granular tag customization system for stats display.

Purpose: Allow users to place individual stats anywhere in their README using specific tags (TODO-IST-KARMA, TODO-IST-DAILY, etc.) while maintaining backward compatibility with legacy TODO-IST:START/END tags.

Output: Dual-mode tag system supporting both legacy (all-in-one) and granular (individual) stat placement.
</objective>

<execution_context>
@/home/claude/.claude/get-shit-done/workflows/execute-plan.md
@/home/claude/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stats-retrieval-display/02-RESEARCH.md
@.planning/phases/02-stats-retrieval-display/02-01-SUMMARY.md
@index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tag detection and granular replacement</name>
  <files>index.js</files>
  <action>
Add dual-mode tag detection and granular tag processing. Place these functions AFTER the formatter functions (from Plan 01) and BEFORE updateReadme:

**1. Add TAG_CONFIG constant mapping tag names to formatters:**

```javascript
// Granular tag configuration - maps tag names to formatter functions
const TAG_CONFIG = {
  'TODO-IST-KARMA': (data) => formatKarmaStat(data.karma),
  'TODO-IST-DAILY': (data) => formatDailyTasksStat(data.days_items),
  'TODO-IST-WEEKLY': (data) => formatWeeklyTasksStat(data.week_items, PREMIUM === "true"),
  'TODO-IST-TOTAL': (data) => formatTotalTasksStat(data.completed_count),
  'TODO-IST-CURRENT-STREAK': (data) => formatCurrentStreakStat(data.goals),
  'TODO-IST-LONGEST-STREAK': (data) => formatLongestStreakStat(data.goals)
};
```

**2. Add detectDisplayMode function:**

```javascript
function detectDisplayMode(readmeContent) {
  const hasLegacyTags = readmeContent.includes('<!-- TODO-IST:START -->') &&
                        readmeContent.includes('<!-- TODO-IST:END -->');

  const hasGranularTags = Object.keys(TAG_CONFIG).some(tag =>
    readmeContent.includes(`<!-- ${tag}:START -->`)
  );

  if (hasGranularTags) return 'granular';
  if (hasLegacyTags) return 'legacy';
  return 'none';
}
```

**3. Add replaceTag function for safe tag replacement:**

```javascript
function replaceTag(content, tagName, newContent) {
  const startTag = `<!-- ${tagName}:START -->`;
  const endTag = `<!-- ${tagName}:END -->`;

  const startIndex = content.indexOf(startTag);
  if (startIndex === -1) {
    core.warning(`${tagName}: Start tag not found`);
    return content;
  }

  const endIndex = content.indexOf(endTag, startIndex);
  if (endIndex === -1) {
    core.warning(`${tagName}: End tag not found (start tag exists at position ${startIndex})`);
    return content;
  }

  const endOfStartTag = startIndex + startTag.length;

  return [
    content.slice(0, endOfStartTag),
    '\n',
    newContent,
    '\n',
    content.slice(endIndex)
  ].join('');
}
```

**4. Add updateReadmeGranular function:**

```javascript
function updateReadmeGranular(data, readmeContent) {
  let updated = readmeContent;
  let processedTags = [];
  let skippedTags = [];

  for (const [tagName, formatter] of Object.entries(TAG_CONFIG)) {
    const startTag = `<!-- ${tagName}:START -->`;

    if (readmeContent.includes(startTag)) {
      const formattedStat = formatter(data);

      if (formattedStat !== null) {
        updated = replaceTag(updated, tagName, formattedStat);
        processedTags.push(tagName);
      } else {
        // Stat unavailable (e.g., premium feature for free user)
        skippedTags.push(tagName);
        core.warning(`${tagName}: Stat unavailable (check premium status or API response)`);
      }
    }
  }

  if (processedTags.length > 0) {
    core.info(`Updated ${processedTags.length} stat(s): ${processedTags.join(', ')}`);
  }

  if (skippedTags.length > 0) {
    core.info(`Skipped ${skippedTags.length} unavailable stat(s): ${skippedTags.join(', ')}`);
  }

  if (processedTags.length === 0 && skippedTags.length === 0) {
    core.warning('No valid TODO-IST granular tags found in README');
  }

  return updated;
}
```

Key implementation details:
- TAG_CONFIG uses hyphen-based names (TODO-IST-KARMA not TODO-IST:KARMA)
- Each tag has START/END markers like legacy mode
- Logs processed/skipped tags for debugging
- Warnings for missing tags help users find typos
  </action>
  <verify>
Run `grep -n "TAG_CONFIG" index.js` to confirm config exists.
Run `grep -n "detectDisplayMode" index.js` to confirm function exists.
Run `grep -n "replaceTag" index.js` to confirm function exists.
Run `grep -n "updateReadmeGranular" index.js` to confirm function exists.
  </verify>
  <done>
TAG_CONFIG maps all 6 stat types to formatter functions.
detectDisplayMode detects legacy vs granular vs none.
replaceTag safely replaces content between tag pairs.
updateReadmeGranular processes all granular tags with logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate dual-mode routing in updateReadme</name>
  <files>index.js, dist/index.js</files>
  <action>
Modify updateReadme to route to legacy or granular processing based on detected mode.

**Replace the current updateReadme function** with a version that:
1. Reads README content
2. Detects display mode
3. Routes to appropriate handler

```javascript
async function updateReadme(data) {
  const readmeContent = fs.readFileSync(README_FILE_PATH, "utf8");
  const mode = detectDisplayMode(readmeContent);

  core.info(`Display mode detected: ${mode}`);

  if (mode === 'none') {
    core.error('No TODO-IST tags found in README. Add either:\n' +
               '  - Legacy: <!-- TODO-IST:START --> and <!-- TODO-IST:END -->\n' +
               '  - Granular: <!-- TODO-IST-KARMA:START --> etc.');
    process.exit(1);
  }

  let newReadme;

  if (mode === 'granular') {
    newReadme = updateReadmeGranular(data, readmeContent);
  } else {
    // Legacy mode - build all stats together
    newReadme = updateReadmeLegacy(data, readmeContent);
  }

  if (newReadme !== readmeContent) {
    core.info("Writing to " + README_FILE_PATH);
    fs.writeFileSync(README_FILE_PATH, newReadme);
    if (!process.env.TEST_MODE) {
      commitReadme();
    }
  } else {
    core.info("No change detected, skipping");
    process.exit(0);
  }
}
```

**Add updateReadmeLegacy function** to handle the existing all-in-one tag behavior:

```javascript
function updateReadmeLegacy(data, readmeContent) {
  const { karma, completed_count, days_items, goals, week_items } = data;

  const stats = [
    formatKarmaStat(karma),
    formatDailyTasksStat(days_items),
    formatWeeklyTasksStat(week_items, PREMIUM === "true"),
    formatTotalTasksStat(completed_count),
    formatCurrentStreakStat(goals),
    formatLongestStreakStat(goals)
  ].filter(Boolean);

  if (stats.length === 0) {
    core.warning('No stats available to display');
    return readmeContent;
  }

  return buildReadme(readmeContent, stats.join("           \n"));
}
```

**Delete the old updateReadme logic** (the todoist array, the inline formatting, etc.).

**Delete or remove the global `todoist = []` and `jobFailFlag` variables** since they're no longer needed with this refactor.

After refactoring, rebuild the bundle:
```bash
npm run build
```
  </action>
  <verify>
Run `grep -n "detectDisplayMode" index.js | grep -v "function"` to confirm it's called in updateReadme.
Run `grep -n "updateReadmeLegacy\|updateReadmeGranular" index.js` to confirm both handlers exist.
Run `grep "let todoist = \[\]" index.js` to confirm old global is removed (should return nothing).
Run `npm run build` to verify build succeeds.
Check `ls -la dist/index.js` to confirm bundle was rebuilt.
  </verify>
  <done>
updateReadme detects mode and routes appropriately.
Legacy mode uses updateReadmeLegacy (same behavior as before).
Granular mode uses updateReadmeGranular.
Old global variables removed.
Build succeeds and dist/index.js is updated.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unknown tag detection for common typos</name>
  <files>index.js, dist/index.js</files>
  <action>
Add helpful detection for common tag typos to help users debug issues.

**Add a function to detect potential typos** near the top of updateReadmeGranular:

```javascript
function detectUnknownTags(readmeContent) {
  // Find all TODO-IST-* tags that aren't in our config
  const tagPattern = /<!-- (TODO-IST-[A-Z-]+):START -->/g;
  const validTags = Object.keys(TAG_CONFIG);
  const unknownTags = [];

  let match;
  while ((match = tagPattern.exec(readmeContent)) !== null) {
    const foundTag = match[1];
    if (!validTags.includes(foundTag)) {
      unknownTags.push(foundTag);
    }
  }

  return unknownTags;
}
```

**Update updateReadmeGranular** to call this function and warn about unknown tags:

At the start of updateReadmeGranular, add:

```javascript
// Check for potential typos
const unknownTags = detectUnknownTags(readmeContent);
if (unknownTags.length > 0) {
  core.warning(`Unknown tag(s) found: ${unknownTags.join(', ')}`);
  core.warning(`Valid tags are: ${Object.keys(TAG_CONFIG).join(', ')}`);
}
```

This helps users when they type `TODO-IST-KARM` instead of `TODO-IST-KARMA`.

Rebuild the bundle:
```bash
npm run build
```
  </action>
  <verify>
Run `grep -n "detectUnknownTags" index.js` to confirm function exists.
Run `grep -n "Unknown tag" index.js` to confirm warning is present.
Run `npm run build` to verify build succeeds.
  </verify>
  <done>
detectUnknownTags function finds tags not in TAG_CONFIG.
updateReadmeGranular warns about unknown tags with list of valid tags.
Build succeeds.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Mode detection works:**
   ```bash
   grep -A5 "function detectDisplayMode" index.js
   # Should show legacy/granular/none detection
   ```

2. **Granular tag config exists:**
   ```bash
   grep -A10 "const TAG_CONFIG" index.js
   # Should show all 6 tag mappings
   ```

3. **Both handlers exist:**
   ```bash
   grep -c "function updateReadme" index.js
   # Expected: 3 (updateReadme, updateReadmeLegacy, updateReadmeGranular)
   ```

4. **Unknown tag detection:**
   ```bash
   grep "Unknown tag" index.js
   # Should find warning message
   ```

5. **Bundle builds:**
   ```bash
   npm run build && echo "Build successful"
   ```

6. **Backward compatibility check:**
   ```bash
   # Ensure legacy tag pattern still works
   grep "TODO-IST:START" index.js
   ```
</verification>

<success_criteria>
- Dual-mode detection works (legacy vs granular)
- Legacy TODO-IST:START/END tags continue working unchanged
- Granular tags (TODO-IST-KARMA, TODO-IST-DAILY, etc.) work independently
- Users can place stats anywhere in README using granular tags
- Helpful warnings for typos and missing tags
- Build succeeds
- All STAT-01 through STAT-07 requirements addressed
</success_criteria>

<output>
After completion, create `.planning/phases/02-stats-retrieval-display/02-02-SUMMARY.md`
</output>
